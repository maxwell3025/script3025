#ifndef SCRIPT3025_PARSER_PARSER_HPP
#define SCRIPT3025_PARSER_PARSER_HPP

#include <algorithm>
#include <deque>
#include <iostream>
#include <memory>
#include <sstream>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <variant>
#include <vector>

#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace parser {

// @brief
// Node in a CST which is generated by a `Parser`.
template <typename T>
struct ConcreteSyntaxTree;

// @brief
// Object which parses strings of type `T` into `ConcreteSyntaxTree`s.
//
// To construct an instance of `Parser`, use `ParserBuilder`.
//
// Formally, this is a [LR(1)](https://en.wikipedia.org/wiki/LR_parser) parser.
template <typename T>
class Parser;

// @brief
// [Builder](https://en.wikipedia.org/wiki/Builder_pattern) class for specifying
// a [canonical LR(1) parser](https://en.wikipedia.org/wiki/Canonical_LR_parser)
// based on the given grammar.
template <typename T>
class ParserBuilder;

namespace {

// From
// https://stackoverflow.com/questions/29855908/c-unordered-set-of-vectors#answer-29855973
template <typename T>
struct VectorHash {
  size_t operator()(const std::vector<T> &v) const {
    std::hash<T> hasher;
    size_t seed = 0;
    for (T i : v) {
      seed ^= hasher(i) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    }
    return seed;
  }
};

template <typename T, typename H = std::hash<T>>
struct UnorderedSetHash {
  size_t operator()(const std::unordered_set<T, H> &set) const {
    H hasher;
    size_t seed = 0;
    for (T element : set) {
      seed ^= hasher(element);
    }
    return seed;
  }
};

// A set of production rules for a single nonterminal with `T` as the symbol
// alphabet.
// For instance, an instance of `PartialRuleset<char>` would be the
// production rules for a single character.
template <typename T>
using PartialRuleset = std::unordered_set<std::vector<T>, VectorHash<T>>;

// A full ruleset for a grammar that has `T` as the symbol alphabet.
// For instance, `TotalRuleset<char>` is the type for grammars on ASCII
// strings.
template <typename T>
using TotalRuleset = std::unordered_map<T, PartialRuleset<T>>;

template <typename T>
void vectorize(std::vector<T> &) {}

template <typename T, typename... Args>
void vectorize(std::vector<T> &vector, T first_element,
               Args... remaining_elements) {
  vector.push_back(first_element);
  vectorize<T>(vector, remaining_elements...);
}

template <typename T, typename... Args>
std::vector<T> vectorize(Args... elements) {
  std::vector<T> output;
  vectorize<T>(output, elements...);
  return output;
}  // LCOV_EXCL_LINE

template <typename T>
struct CanonicalSetEntry {
 public:
  T target;
  const std::vector<T> sentential_form;
  size_t index;
  T following_symbol;

  CanonicalSetEntry(T target, const std::vector<T> &sentential_form,
                    T following_symbol)
      : target(target),
        sentential_form(sentential_form),
        index(0),
        following_symbol(following_symbol) {}

  CanonicalSetEntry<T> next() const {
    CanonicalSetEntry<T> next = CanonicalSetEntry(*this);
    ++next.index;
    return next;
  }

  bool operator==(const CanonicalSetEntry &rhs) const {
    return target == rhs.target && sentential_form == rhs.sentential_form &&
           index == rhs.index && following_symbol == rhs.following_symbol;
  }
};

// Hash function for `CanonicalSetEntry`.
template <typename T>
struct CanonicalSetEntryHash {
  size_t operator()(const CanonicalSetEntry<T> &entry) const {
    std::hash<T> t_hasher;
    std::hash<size_t> size_t_hasher;
    VectorHash<T> vec_hasher;

    size_t seed = 0;
    seed ^= t_hasher(entry.following_symbol) + 0x9e3779b9 + (seed << 6) +
            (seed >> 2);
    seed ^= size_t_hasher(entry.index) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    seed ^= vec_hasher(entry.sentential_form) + 0x9e3779b9 + (seed << 6) +
            (seed >> 2);
    seed ^= t_hasher(entry.target) + 0x9e3779b9 + (seed << 6) + (seed >> 2);
    return seed;
  }
};

template <typename T>
struct ShiftAction {
  size_t resulting_state;
  ShiftAction(size_t resulting_state) : resulting_state(resulting_state) {}
};

template <typename T>
struct ReduceAction {
  size_t pop_qty;
  T result;
  ReduceAction(size_t pop_qty, T result) : pop_qty(pop_qty), result(result) {}
};

template <typename T>
using Action = std::variant<ShiftAction<T>, ReduceAction<T>>;

template <typename T>
struct AnnotatedNode {
  ConcreteSyntaxTree<T> symbol;
  size_t annotation;

  // TODO also try doing this with a non-reference type ans see if it breaks.
  AnnotatedNode(ConcreteSyntaxTree<T> &&symbol, size_t annotation)
      : symbol(std::move(symbol)), annotation(annotation) {}

  AnnotatedNode(AnnotatedNode &&other)
      : symbol(std::move(other.symbol)), annotation(other.annotation) {}
};

}  // namespace

template <typename T>
struct ConcreteSyntaxTree {
  template <typename U>
  friend std::ostream &operator<<(std::ostream &os,
                                  const ConcreteSyntaxTree<U> &tree);

 public:
  T symbol;
  std::vector<ConcreteSyntaxTree<T>> children;

  ConcreteSyntaxTree(T symbol) : symbol(symbol) {}

  ConcreteSyntaxTree(ConcreteSyntaxTree<T> &&other)
      : symbol(other.symbol), children(std::move(other.children)) {}

  [[nodiscard]] std::vector<T> sentence() const {
    std::vector<T> sentence;
    std::for_each(children.begin(), children.end(),
                  [&](const ConcreteSyntaxTree<T> &child) {
                    sentence.push_back(child.symbol);
                  });
    return sentence;
  }

  std::string to_string() const {
    std::stringstream output;
    std::vector<std::string> stack;
    stringify_internal(output, stack, true);
    return output.str();
  }

 private:
  void stringify_internal(std::ostream &os,
                          std::vector<std::string> &current_stack,
                          bool is_last) const {
    for (const std::string &c : current_stack) {
      os << c;
    }
    if (is_last) {
      os << "└";
      current_stack.push_back(" ");
    } else {
      os << "├";
      current_stack.push_back("│");
    }

    if (children.size() != 0) {
      os << "┬";
    } else {
      os << "─";
    }

    os << symbol << std::endl;
    for (size_t child_index = 0; child_index < children.size(); ++child_index) {
      children[child_index].stringify_internal(
          os, current_stack, child_index == children.size() - 1);
    }
    current_stack.pop_back();
  }
};

template <typename T>
std::ostream &operator<<(std::ostream &os, const ConcreteSyntaxTree<T> &tree) {
  std::vector<std::string> character_stack;
  tree.stringify_internal(os, character_stack, true);
  return os;
}

template <typename T>
class ParserBuilder;

template <typename T>
class Parser {
  friend class ParserBuilder<T>;

 public:
  // @brief
  // Parse a token iterator into a `ConcreteSyntaxTree`.
  template <typename Iterator>
  ConcreteSyntaxTree<T> parse(Iterator begin, Iterator end);

 private:
  Parser(const std::vector<std::unordered_map<T, Action<T>>> &action_table,
         T goal, T end);
  static std::shared_ptr<spdlog::logger> get_logger();

  T goal_symbol;
  T terminal_symbol;
  std::vector<std::unordered_map<T, Action<T>>> action_table;
};

template <typename T>
class ParserBuilder {
 public:
  ParserBuilder(T goal, T end) : goal_symbol(goal), terminal_symbol(end) {}

  // @brief
  // Adds a rule to the grammar stored by the builder.
  //
  // @example
  // ```
  // ParserBuilder<char> my_parser_builder('G', '$');
  // // adds A -> bBA to the grammar.
  // my_parser_builder.add_rule('A', 'b', 'B', 'A');
  // ```
  template <typename... Args>
  ParserBuilder &rule(T nonterminal, Args... sentence);

  // @brief
  // Build an instance of `Parser` according to the rules given thus far.
  //
  // This method may fail if the given grammar is not LR(1).
  //
  // @throws TODO
  Parser<T> build();

 private:
  using CanonicalSet =
      std::unordered_set<CanonicalSetEntry<T>, CanonicalSetEntryHash<T>>;
  using CanonicalSetHash =
      UnorderedSetHash<CanonicalSetEntry<T>, CanonicalSetEntryHash<T>>;
  using CanonicalCollection =
      std::unordered_set<CanonicalSet, CanonicalSetHash>;

  // Populates `terminals` and `nonterminals` according to `ruleset`.
  void infer_types();

  // Returns `true` if `sentence` might produce an empty string according to
  // `possibly_empty`.
  // `possibly_empty` should be a superset of the non-terminals that can
  // actually evaluate to the empty string.
  bool is_sentence_empty(const std::vector<T> &sentence);

  // Returns `true` if `possibly_empty` and the rules for `symbol` guarantee
  // that `symbol` produces a nonempty string.
  // Otherwise, returns `false`.
  bool definitely_nonempty(const T &symbol);

  // Determines the set of non-terminals in a set that could produce the empty
  // string.
  std::unordered_set<T> generate_empty_set();

  // Generates the first set for each nonterminal symbol.
  std::unordered_map<T, std::unordered_set<T>> generate_first_set();

  // Expands a canonical set using the curent rules.
  void extend(CanonicalSet &canonical_set) const;

  // Shifts a character into a canonical set.
  CanonicalSet shift(const CanonicalSet &canonical_set, T lookahead) const;

  // Converts a `CanonicalSet` into a string
  std::string stringify(const CanonicalSet &canonical_set) const;

  static std::shared_ptr<spdlog::logger> get_logger();

  T goal_symbol;
  T terminal_symbol;
  TotalRuleset<T> ruleset;
  std::unordered_set<T> terminals;
  std::unordered_set<T> nonterminals;
  std::unordered_set<T> possibly_empty;
  std::unordered_map<T, std::unordered_set<T>> first_set;
};

template <typename T>
template <typename... Args>
ParserBuilder<T> &ParserBuilder<T>::rule(T nonterminal, Args... sentence) {
  std::vector<T> sentence_vector = vectorize<T>(sentence...);
  ruleset[nonterminal].insert(sentence_vector);
  return *this;
}

template <typename T>
void ParserBuilder<T>::infer_types() {
  for (std::pair<T, PartialRuleset<T>> symbol_ruleset : ruleset) {
    for (std::vector<T> sentence : symbol_ruleset.second) {
      std::copy(sentence.begin(), sentence.end(),
                std::inserter(terminals, terminals.end()));
    }
  }

  for (auto it = ruleset.begin(); it != ruleset.end(); ++it) {
    const T &nonterminal = it->first;
    nonterminals.insert(nonterminal);
    terminals.erase(nonterminal);
  }
}

template <typename T>
bool ParserBuilder<T>::is_sentence_empty(const std::vector<T> &sentence) {
  for (const T &character : sentence) {
    if (possibly_empty.find(character) == possibly_empty.end()) {
      return false;
    }
  }
  return true;
}

template <typename T>
bool ParserBuilder<T>::definitely_nonempty(const T &symbol) {
  bool symbol_has_rule = ruleset.find(symbol) == ruleset.end();
  const PartialRuleset<T> &productions =
      symbol_has_rule ? PartialRuleset<T>() : ruleset.at(symbol);

  for (const std::vector<T> &sentence : productions) {
    if (is_sentence_empty(sentence)) {
      return false;
    }
  }

  return true;
}

template <typename T>
std::unordered_set<T> ParserBuilder<T>::generate_empty_set() {
  possibly_empty = nonterminals;
  bool changed = true;
  while (changed) {
    changed = false;
    std::unordered_set<T> nonempty;
    for (const T &symbol : possibly_empty) {
      if (definitely_nonempty(symbol)) {
        changed = true;
        nonempty.insert(symbol);
      }
    }
    for (auto it = nonempty.begin(); it != nonempty.end(); it++) {
      possibly_empty.erase(*it);
    }
  }
  return possibly_empty;
}

template <typename T>
std::unordered_map<T, std::unordered_set<T>>
ParserBuilder<T>::generate_first_set() {
  bool changed = true;
  while (changed) {
    changed = false;
    for (const T &symbol : nonterminals) {
      const PartialRuleset<T> &symbol_ruleset = ruleset.at(symbol);
      size_t original_size = first_set[symbol].size();
      for (const std::vector<T> &sentence : symbol_ruleset) {
        if (sentence.size() == 0) {
          continue;
        } else if (nonterminals.find(sentence[0]) == nonterminals.end()) {
          first_set[symbol].insert(sentence[0]);
        } else {
          for (const T &prefix_symbol : sentence) {
            first_set[symbol].merge(
                std::unordered_set<T>(first_set[prefix_symbol]));
            if (possibly_empty.find(prefix_symbol) == possibly_empty.end()) {
              break;
            }
          }
        }
      }
      if (first_set[symbol].size() != original_size) {
        changed = true;
      }
    }
  }
  return first_set;
}

template <typename T>
Parser<T> ParserBuilder<T>::build() {
  nonterminals.clear();
  terminals.clear();
  possibly_empty.clear();
  first_set.clear();

  infer_types();
  generate_empty_set();
  generate_first_set();

  std::unordered_set<T> symbols = {terminal_symbol};
  symbols.merge(std::unordered_set<T>(terminals));
  symbols.merge(std::unordered_set<T>(nonterminals));

  CanonicalCollection canonical_collection;

  std::deque<CanonicalSet> bfs_queue;

  // On the set S, and seeing a lookahead L, do action action_table[S, L].
  std::unordered_map<CanonicalSet, std::unordered_map<T, Action<T>>,
                     CanonicalSetHash>
      action_table;

  CanonicalSet initial_set;
  initial_set.insert(CanonicalSetEntry<T>(
      goal_symbol, std::vector<T>{goal_symbol}, terminal_symbol));

  std::vector<CanonicalSet> numbering;

  extend(initial_set);

  bfs_queue.push_back(initial_set);
  while (!bfs_queue.empty()) {
    CanonicalSet current_set = bfs_queue.front();
    bfs_queue.pop_front();

    if (canonical_collection.find(current_set) != canonical_collection.end())
      continue;

    canonical_collection.insert(current_set);

    SPDLOG_LOGGER_TRACE(get_logger(),
                        "Processing canonical set {}:\n"
                        "{}",
                        numbering.size(), stringify(current_set));

    numbering.push_back(current_set);

    // Figure out how to handle the lookahead for each canonical set.
    // We defer construction of shifts until after the numbering is stable
    for (T symbol : symbols) {
      bool found_action = false;
      // We look through all entries and check if we can reduce them with
      // the current symbol.
      for (const CanonicalSetEntry<T> &entry : current_set) {
        // If we can reduce the current symbol.
        if (entry.index == entry.sentential_form.size() &&
            entry.following_symbol == symbol) {
          if (found_action) {
            SPDLOG_LOGGER_ERROR(get_logger(),
                                "Error: Reduce-Reduce conflict with \'{}\' on\n"
                                "{}",
                                symbol, stringify(current_set));
            throw std::runtime_error("Reduce-Reduce conflict");
          }
          found_action = true;
          action_table[current_set].insert(
              {symbol,
               ReduceAction<T>(entry.sentential_form.size(), entry.target)});
        }
      }
      CanonicalSet shifted = shift(current_set, symbol);
      if (!shifted.empty()) {
        if (found_action) {
          SPDLOG_LOGGER_ERROR(get_logger(),
                              "Error: Shift-Reduce conflict with \'{}\' on\n"
                              "{}",
                              symbol, stringify(current_set));
          throw std::runtime_error("Shift-Reduce conflict");
        }
        bfs_queue.push_back(shifted);
      }
    }
  }

  // Populate the action table with the shift actions.
  for (size_t canonical_set_index = 0; canonical_set_index < numbering.size();
       ++canonical_set_index) {
    CanonicalSet canonical_set = numbering[canonical_set_index];
    for (T symbol : symbols) {
      CanonicalSet shifted_set = shift(canonical_set, symbol);
      if (!shifted_set.empty()) {
        size_t new_index = 0;
        while (numbering[new_index] != shifted_set) ++new_index;
        action_table[canonical_set].insert(
            {symbol, Action<T>(ShiftAction<T>(new_index))});
      }
    }
  }

  std::vector<std::unordered_map<T, Action<T>>> action_table_vector;
  for (CanonicalSet canonical_set : numbering) {
    action_table_vector.push_back(action_table[canonical_set]);
  }

  return Parser<T>(action_table_vector, goal_symbol, terminal_symbol);
}

template <typename T>
void ParserBuilder<T>::extend(CanonicalSet &canonical_set) const {
  size_t prev_size = -1;
  while (canonical_set.size() != prev_size) {
    prev_size = canonical_set.size();
    CanonicalSet new_entries;
    for (const CanonicalSetEntry<T> &entry : canonical_set) {
      // We expand with the canonical entries for starting nonterminals.
      // We can't expand if there is no "next" symbol.
      if (entry.index >= entry.sentential_form.size()) continue;

      T current_symbol = entry.sentential_form[entry.index];
      // We can't expand terminals
      if (nonterminals.find(current_symbol) == nonterminals.end()) continue;

      // Go through the following symbol and merge in first symbols until
      // we hit a nonempty.
      std::unordered_set<T> possible_follows;
      size_t following_symbol_index = entry.index + 1;
      for (; following_symbol_index < entry.sentential_form.size();
           ++following_symbol_index) {
        T following_symbol = entry.sentential_form[following_symbol_index];

        // We merge all of the first symbols for the current following symbol
        // into the possible follows.
        if (nonterminals.find(following_symbol) == nonterminals.end()) {
          possible_follows.insert(following_symbol);
        } else {
          possible_follows.merge(
              std::unordered_set<T>(first_set.at(following_symbol)));
        }

        if (possibly_empty.find(following_symbol) == possibly_empty.end()) {
          break;
        }
      }

      if (following_symbol_index == entry.sentential_form.size()) {
        possible_follows.insert(entry.following_symbol);
      }

      for (T follow_symbol : possible_follows) {
        for (const std::vector<T> &sentential_form :
             ruleset.at(current_symbol)) {
          new_entries.insert(CanonicalSetEntry<T>(
              current_symbol, sentential_form, follow_symbol));
        }
      }
    }
    canonical_set.merge(CanonicalSet(new_entries));
  }
}

template <typename T>
typename ParserBuilder<T>::CanonicalSet ParserBuilder<T>::shift(
    const CanonicalSet &canonical_set, T lookahead) const {
  CanonicalSet shifted_set;
  for (const CanonicalSetEntry<T> &current_entry : canonical_set) {
    if (current_entry.index == current_entry.sentential_form.size()) continue;
    if (current_entry.sentential_form[current_entry.index] != lookahead)
      continue;
    shifted_set.insert(current_entry.next());
  }
  extend(shifted_set);
  return shifted_set;
}

template <typename T>
std::string ParserBuilder<T>::stringify(
    const CanonicalSet &canonical_set) const {
  std::stringstream output;
  for (const CanonicalSetEntry<T> &entry : canonical_set) {
    output << entry.target;
    output << " <- ";
    for (size_t i = 0; i < entry.sentential_form.size(); ++i) {
      if (i == entry.index) output << "·";
      output << entry.sentential_form[i];
    }
    if (entry.sentential_form.size() == entry.index) output << "·";
    output << ",";
    output << entry.following_symbol;
    output << std::endl;
  }
  return output.str();
}

template <typename T>
std::shared_ptr<spdlog::logger> ParserBuilder<T>::get_logger() {
  static std::shared_ptr<spdlog::logger> logger =
      ([&]() -> std::shared_ptr<spdlog::logger> {
        logger = spdlog::stderr_color_mt("parser::ParserBuilder",
                                         spdlog::color_mode::always);
        logger->set_level(spdlog::level::warn);
        logger->set_pattern("%^[%l] [tid=%t] [%T.%F] [%s:%#] %v%$");
        return logger;
      })();
  return logger;
}

template <typename T>
template <typename Iterator>
ConcreteSyntaxTree<T> Parser<T>::parse(Iterator begin, Iterator end) {
  std::vector<AnnotatedNode<T>> stack;
  while (true) {
    // Log current derivation
    std::stringstream stack_trace;
    stack_trace << " 0 ";
    for (AnnotatedNode<T> &node : stack) {
      stack_trace << node.symbol.symbol << " " << node.annotation << " ";
    }
    stack_trace << "        ";
    for (auto it = begin; it != end; ++it) {
      stack_trace << *it;
    }
    SPDLOG_LOGGER_TRACE(get_logger(), "{}", stack_trace.str());

    if (begin == end && stack.size() == 1) {
      ConcreteSyntaxTree<T> return_value = std::move(stack[0].symbol);
      stack.pop_back();
      return return_value;
    }

    T current_lookahead;
    if (begin == end) {
      current_lookahead = terminal_symbol;
    } else {
      current_lookahead = *begin;
    }

    size_t current_state = 0;
    if (!stack.empty()) {
      current_state = stack[stack.size() - 1].annotation;
    }

    if (action_table[current_state].find(current_lookahead) ==
        action_table[current_state].end()) {
      SPDLOG_LOGGER_ERROR(get_logger(),
                          "Error: no action for state {} on lookahead {}",
                          current_state, current_lookahead);
    }

    Action<T> current_action =
        action_table[current_state].at(current_lookahead);

    if (std::holds_alternative<ShiftAction<T>>(current_action)) {
      ShiftAction<T> shift_action = std::get<ShiftAction<T>>(current_action);

      ConcreteSyntaxTree<T> node = ConcreteSyntaxTree<T>(current_lookahead);

      stack.push_back(
          AnnotatedNode<T>(std::move(node), shift_action.resulting_state));

      ++begin;
    } else if (std::holds_alternative<ReduceAction<T>>(current_action)) {
      ReduceAction<T> reduce_action = std::get<ReduceAction<T>>(current_action);

      ConcreteSyntaxTree<T> node = ConcreteSyntaxTree<T>(reduce_action.result);

      if (stack.size() < reduce_action.pop_qty) {
        SPDLOG_LOGGER_ERROR(get_logger(),
                            "Error: trying to reduce {} from stack of size {}",
                            reduce_action.pop_qty, stack.size());
      }

      for (size_t i = 0; i < reduce_action.pop_qty; i++) {
        (node.children)
            .emplace_back(std::move(
                stack[stack.size() - reduce_action.pop_qty + i].symbol));
        stack[stack.size() - reduce_action.pop_qty + i].symbol;
      }

      for (size_t i = 0; i < reduce_action.pop_qty; i++) {
        stack.pop_back();
      }

      // Try to shift
      size_t pre_reduce_state = 0;
      if (!stack.empty()) {
        pre_reduce_state = stack.back().annotation;
      }

      if (action_table[pre_reduce_state].find(reduce_action.result) ==
          action_table[pre_reduce_state].end()) {
        SPDLOG_LOGGER_ERROR(get_logger(),
                            "Error: no action on state {} with symbol {}",
                            pre_reduce_state, reduce_action.result);
      }
      Action<T> action =
          action_table[pre_reduce_state].at(reduce_action.result);

      if (!std::holds_alternative<ShiftAction<T>>(action)) {
        SPDLOG_LOGGER_ERROR(
            get_logger(), "Error: non-shift action on state {} with symbol {}",
            pre_reduce_state, reduce_action.result);
      }
      ShiftAction<T> shift_action = std::get<ShiftAction<T>>(action);

      stack.push_back(
          AnnotatedNode<T>(std::move(node), shift_action.resulting_state));
    }
  }
}

template <typename T>
Parser<T>::Parser(
    const std::vector<std::unordered_map<T, Action<T>>> &action_table, T goal,
    T end)
    : goal_symbol(goal), terminal_symbol(end), action_table(action_table) {}

template <typename T>
std::shared_ptr<spdlog::logger> Parser<T>::get_logger() {
  static std::shared_ptr<spdlog::logger> logger =
      ([&]() -> std::shared_ptr<spdlog::logger> {
        logger = spdlog::stderr_color_mt("parser::Parser",
                                         spdlog::color_mode::always);
        logger->set_level(spdlog::level::warn);
        logger->set_pattern("%^[%l] [tid=%t] [%T.%F] [%s:%#] %v%$");
        return logger;
      })();
  return logger;
}

}  // namespace parser

template <typename T>
struct fmt::formatter<parser::ConcreteSyntaxTree<T>> {
  template <typename ParseContext>
  constexpr auto parse(ParseContext &ctx) {
    return ctx.begin();
  }

  template <typename FormatContext>
  auto format(parser::ConcreteSyntaxTree<T> const &tree,
              FormatContext &ctx) const {
    return fmt::format_to(ctx.out(), "{0}", tree.to_string());
  }
};

#endif
